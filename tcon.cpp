//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include "tcon.h"

///////////////////////////////////////////////
#include "video.h"
#include "comm.h"

//#import "CA200Srvr.dll"

//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "active_testLib_OCX"
#pragma resource "*.dfm"
Ttcon_form *tcon_form;


AnsiString _pol_control_label_group[] = {
"VSYNC generated by TCON for RGB format DVI output ",
"HSYNC generated by TCON  for RGB format DVI output",
"DE generated by TCON for RGB format DVI output",
"CPH3 Polarity Control",
"CPH2 Polarity Control",
"CPH1 Polarity Control",
"DE Generate by TCON",
"Vsync Generate by TCON ",
"Hsync Generate by TCON",
"De polarity control",
"Vsync polarity control ",
"Hsync polarity control",

};

AnsiString _tcon_control_label_group_1[] = {
"STH1 Horizontal Start",
"STH1 Vertical Start",
"STH2 Horizontal Start",
"STH2 Vertical Start",
"OEH Horizontal Start",
"OEH Vertical Start",
"VCOM Vertical Start",
"CPV1 Horizontal Start",
"CPV1 Vertical Start",
"CPV2Horizontal Start",
"CPV2 Vertical Start",
"STV1 Horizontal Start",
"STV1 Vertical Start",
"STV2 Horizontal Start",
"STV2 Vertical Start",
"OEV1 Horizontal Start",
"OEV1 Vertical Start",
"OEV2Horizontal Start",
"OEV2 Vertical Start",
"OEV3 Horizontal Start",
"OEV3 Vertical Start",
};
AnsiString _tcon_control_label_group_2[] = {
"STH1 Horizontal End",
"STH1 Vertical End",
"STH2 Horizontal End",
"STH2 Vertical End",
"OEH Horizontal End",
"OEH Vertical End",
"VCOM Vertical End",
"CPV1 Horizontal End",
"CPV1 Vertical End",
"CPV2 Horizontal End",
"CPV2 Vertical End",
"STV1 Horizontal End",
"STV1 Vertical End",
"STV2 Horizontal End",
"STV2 Vertical End",
"OEV1 Horizontal End",
"OEV1 Vertical End",
"OEV2 Horizontal End",
"OEV2Vertical End",
"OEV3 Horizontal End",
"OEV3 Vertical End",
};

AnsiString LCD_PWR_ADDR_1[] = {
"LCD VDD control",
"LCD VBL control",
"LCD GPIO control",
"",
"LCD PWM0 LOW Count",
"LCD PWM1 LOW Count",
"Invert data count  define",
};

AnsiString LCD_PWR_ADDR_2[] = {
"pll_ctrl",
"pll_ctrl2",
"pll_ctrl3",
"clk_ctrl",
"LCD PWM0 High Count",
"LCD PWM1 High Count",
"Invert data output Enable",
};

AnsiString TCON_MISC_SEL[] = {
"STH2 is Line signal",
"STH1 is Line Signal",
"OEH is Line Signal",
"VCOM is Line Signal",
"VCOM switched double lines",
"CPV2 is Line Signal",
"CPV1 is Line Signal",
"STV2 is frame Signal",
"STV1 is frame Signal",
"OEV3/2/1 look like one signal",
"OEV3 is Line Signal",
"OEV2 is Line Signal",
"OEV1 is Line Signal",
};

AnsiString DUAL_PORT_CNTL[] = {
"OUTPUT_YUV",
"DUAL_IDF",
"DUAL_ISF",
"CPH3/INVT pin select",
"CPH3/2/1 Output 3 phases",
"LCD_LVDS_SEL54",
"LCD_LVDS_SEL27",
"LCD_TTL_SEL",
"DUAL_LVDC_EN",
"PORT_SWP",
"R/B Swapped in data path",
"Bit Swap in data path(7:0->0:7)",
};

///////////////////////////////////////////////////////////

/*	write_reg =0,
	read_reg ,	
	write_reg_bit,
	read_reg_bit
*/
#define LCD_PWR_ADDR 	0x4bb

PC_rw_register rw_reg_lcd_pwr_addr1[] ={
	{write_reg_bit, 5,LCD_PWR_ADDR,1},
	{write_reg_bit ,4 ,LCD_PWR_ADDR,1},
	{write_reg_bit, 3,LCD_PWR_ADDR, 3},//+0x01£¬¼´ÉèÖÃ¼Ä´æÆ÷0x00,bit25~bit26=0x01;
	
	{write_reg , 0, LCD_PWR_ADDR +1 , 1},//+0x00£¬¼´ÉèÖÃ¼Ä´æÆ÷0x00,bit25~bit26=0x00;
	{write_reg , 0, LCD_PWR_ADDR +3 , 1},//+0x00£¬¼´ÉèÖÃ¼Ä´æÆ÷0x00,bit25~bit26=0x00;

	{write_reg_bit , 0, LCD_PWR_ADDR +4 , 3},// define

};

PC_rw_register rw_reg_lcd_pwr_addr2[] ={
	{write_reg , 0, 0x15c , 1},//+0x00£¬¼´ÉèÖÃ¼Ä´æÆ÷0x00,bit25~bit26=0x00;
	{write_reg , 0, 0x164 , 1},//+0x00£¬¼´ÉèÖÃ¼Ä´æÆ÷0x00,bit25~bit26=0x00;
	{write_reg , 0, 0x165 , 1},//+0x00£¬¼´ÉèÖÃ¼Ä´æÆ÷0x00,bit25~bit26=0x00;
	{write_reg , 0, 0x15f , 1},//+0x00£¬¼´ÉèÖÃ¼Ä´æÆ÷0x00,bit25~bit26=0x00;
	
	{write_reg , 0, LCD_PWR_ADDR +2 , 1},//+0x00£¬¼´ÉèÖÃ¼Ä´æÆ÷0x00,bit25~bit26=0x00;
	{write_reg , 0, LCD_PWR_ADDR + 4 , 1},//+0x00£¬¼´ÉèÖÃ¼Ä´æÆ÷0x00,bit25~bit26=0x00;
	
	{write_reg , 4, LCD_PWR_ADDR +5 , 1},//+0x00£¬¼´ÉèÖÃ¼Ä´æÆ÷0x00,bit25~bit26=0x00;
};

#define tcom_misc_1_index 6
#define tcom_misc_2_index 7

PC_rw_register rw_reg_tcom_misc_1[] ={
	{write_reg_bit, 12,LCD_PWR_ADDR +tcom_misc_1_index,1},
	{write_reg_bit, 11,LCD_PWR_ADDR +tcom_misc_1_index,1},
	{write_reg_bit, 10,LCD_PWR_ADDR +tcom_misc_1_index,1},
	{write_reg_bit, 9,LCD_PWR_ADDR +tcom_misc_1_index,1},
	{write_reg_bit, 8,LCD_PWR_ADDR +tcom_misc_1_index,1},
	{write_reg_bit, 7,LCD_PWR_ADDR +tcom_misc_1_index,1},
	{write_reg_bit, 6,LCD_PWR_ADDR +tcom_misc_1_index,1},
	{write_reg_bit, 5,LCD_PWR_ADDR +tcom_misc_1_index,1},
	{write_reg_bit, 4,LCD_PWR_ADDR +tcom_misc_1_index,1},
	{write_reg_bit, 3,LCD_PWR_ADDR +tcom_misc_1_index,1},
	{write_reg_bit, 2,LCD_PWR_ADDR +tcom_misc_1_index,1},
	{write_reg_bit, 1,LCD_PWR_ADDR +tcom_misc_1_index,1},
	{write_reg_bit, 0,LCD_PWR_ADDR +tcom_misc_1_index,1},

};

PC_rw_register rw_reg_tcom_misc_2[] ={
	{write_reg_bit, 15,LCD_PWR_ADDR +tcom_misc_2_index,1},
	{write_reg_bit, 12,LCD_PWR_ADDR +tcom_misc_2_index,3},
	{write_reg_bit, 9,LCD_PWR_ADDR +tcom_misc_2_index,3},
	
	{write_reg_bit, 10,LCD_PWR_ADDR +tcom_misc_2_index,1},
	{write_reg_bit, 9,LCD_PWR_ADDR +tcom_misc_2_index,1},
	{write_reg_bit, 8,LCD_PWR_ADDR +tcom_misc_2_index,1},
	{write_reg_bit, 7,LCD_PWR_ADDR +tcom_misc_2_index,1},
	{write_reg_bit, 6,LCD_PWR_ADDR +tcom_misc_2_index,1},
	{write_reg_bit, 5,LCD_PWR_ADDR +tcom_misc_2_index,1},
	{write_reg_bit, 4,LCD_PWR_ADDR +tcom_misc_2_index,1},
	{write_reg_bit, 3,LCD_PWR_ADDR +tcom_misc_2_index,1},
	{write_reg_bit, 2,LCD_PWR_ADDR +tcom_misc_2_index,1},
	{write_reg_bit, 1,LCD_PWR_ADDR +tcom_misc_2_index,1},
	{write_reg_bit, 0,LCD_PWR_ADDR +tcom_misc_2_index,1},
};

////////////////////////////////////////////////
AnsiString *_control_label_groups[]={_tcon_control_label_group_1,_tcon_control_label_group_2 ,
	LCD_PWR_ADDR_1,  LCD_PWR_ADDR_2,
	TCON_MISC_SEL, DUAL_PORT_CNTL};

int row_number[]={21, 21, 7, 7, 13, 12};

TStringGrid *stringgrid_group[6];

TStringGrid *pCurrent_Grid = NULL;
int _current_row;

////////////////////////////////////////////////////////////////////////////
bool send_tcon( byte *pdata, int data_size , PC_rw_register rw_reg);
bool send_tcon( byte *pdata, int data_size , PC_rw_register rw_reg)
{
	send_reg_command( pdata,  data_size, rw_reg, 3, 1 );

	return true;

}
//---------------------------------------------------------------------------
__fastcall Ttcon_form::Ttcon_form(TComponent* Owner)
        : TForm(Owner)
{
	int i;

	 Panel3->Top= 30;
        Panel3->Left= 330;
        Panel3->Visible = false;
	 Panel3->Height = 460;//430;	
	 Panel3->Width = 620;	

	 GroupBox2->Height = 600;

	/////////////////////////////////////////////////////////////
	
        TLabel *pGroup[] = {Label5,Label6,Label7,Label8,Label9,
                Label10, Label11,Label12,Label13,Label14,
                Label15, Label16//,Label,Label,Label,Label,
        };

        TCheckBox *pCheck_box_Group[] = {CheckBox1,CheckBox2,CheckBox3,//CheckBox4,
                //CheckBox5,
                CheckBox6,CheckBox7,CheckBox8,CheckBox9,CheckBox10,
                CheckBox11,CheckBox12, CheckBox13,CheckBox14,
                //CheckBox15,           CheckBox24, //CheckBox,CheckBox,
        };

        for( i =0; i<sizeof(pGroup)/sizeof(TLabel *);i++)
        {
            pGroup[i]->Caption =  _pol_control_label_group[i];
            pGroup[i]->Left = 8;
            pGroup[i]->Top = 20 +  i*20;

            pCheck_box_Group[i]->Left = 275;
            pCheck_box_Group[i]->Top = 20 +  i*20;
        }

	////////////////////////////////////////////////////////////////

	TStringGrid * pstringgrid_group[]={StringGrid1, StringGrid2,
		StringGrid3,StringGrid4, StringGrid5,StringGrid6};

	memcpy(stringgrid_group, pstringgrid_group,sizeof(stringgrid_group) );

	TStringGrid *pGrid;

	for( i =0; i<sizeof(stringgrid_group)/sizeof(TStringGrid *);i++)
        {
        	pGrid = stringgrid_group[i];

		pGrid->FixedColor = clWhite; 
		pGrid->ColCount = 2;
		pGrid->RowCount = row_number[i] +1;  //
		pGrid->Width = 300;
		pGrid->Height = 60 * pGrid->RowCount;;

		pGrid->DefaultColWidth = 60;
		pGrid->DefaultRowHeight = 18;
              pGrid->ColWidths[0] = pGrid->Width - 80;
              pGrid->RowHeights[0] = 1;

		pGrid->Top =30;
		pGrid->Left = (pGrid->Width  +  10) *(i%2) + 30;	  

		AnsiString *pLabel = _control_label_groups[i];
		for(int  k =0; k< pGrid->RowCount-1 ;k++)
		{
			pGrid->Rows[k+1]->Text = "Index" + IntToStr(k);//_tcon_control_label_group_1[i0];
			pGrid->Cells[ 1][k+1] = "3F";
		}
        }
	
	StringGrid5->Top = 190;
	StringGrid6->Top = StringGrid5->Top ;;

	///////////////////////////////////////////////////////////////
       pGrid = StringGrid7; 
	{
		//pGrid->FixedColor = clWhite;
		pGrid->ColCount = 4;
		pGrid->RowCount =  30;  //
		pGrid->Width = 300;
		pGrid->Height = 300;;

		pGrid->DefaultColWidth = 60;
		pGrid->DefaultRowHeight = 18;
              pGrid->ColWidths[0] = 100;

 		for(int  i0 =0; i0< pGrid->RowCount-1 ;i0++)
		{
			pGrid->Rows[i0+1]->Text = "Index" + IntToStr( i0 );//_tcon_control_label_group_1[i0];
			//pGrid->Cells[ 1][i0+1] = "3F";
		}
		i=1;
		pGrid->Cols[i++]->Text = "Red";
		pGrid->Cols[i++]->Text = "Green";
		pGrid->Cols[i++]->Text = "Blue";
        }

        draw_axis_frame(this); 
}
//---------------------------------------------------------------------------

void __fastcall Ttcon_form::timing_send(TObject *Sender)
{
     if(Panel3->Visible)
        Panel3->Visible = false;
     else
        Panel3->Visible = true;
}


//---------------------------------------------------------------------------

void __fastcall Ttcon_form::timing_get(TObject *Sender)
{
	byte data;
       int data_size = 1;
	PC_rw_register rw_reg = {2,31, 0x0017,1};

	int row = _current_row;
	int nbase_reg;
	char *stop;

	////////////////////////////////////////////////////////////////
	memset((char *)&rw_reg, NULL, sizeof(rw_reg));
	
	
	TStringGrid *pGrid = pCurrent_Grid;

	if( !pGrid) return;

	short base_reg_group[]={0x490, 0x491, 0x0, 0,
				0x4c1, 0x4c2};

	for(int  i =0; i<sizeof(stringgrid_group)/sizeof(TStringGrid *);i++)
       {
		if( pGrid== stringgrid_group[i])
		{
			
			switch(i)
			{
				case 0:
				case 1:
					nbase_reg = base_reg_group[i];
					rw_reg.rwRegBit = write_reg;//
					rw_reg.startBit = 0;// = startBit;

					rw_reg.addReg = nbase_reg + row * 2;
		                     if(row>= 6)
		                            rw_reg.addReg +=1;

					rw_reg.RegBitLength = 1;//

					break;
				
				case 2:
					memcpy(&rw_reg,&rw_reg_lcd_pwr_addr1[row], sizeof(rw_reg));
					break;

			       case 3:
					memcpy(&rw_reg,&rw_reg_lcd_pwr_addr2[row], sizeof(rw_reg));
					break;

				case 4:
					memcpy(&rw_reg, &rw_reg_tcom_misc_1[row], sizeof(rw_reg));
					break;
				
				case 5:
					memcpy(&rw_reg, &rw_reg_tcom_misc_2[row], sizeof(rw_reg));
					break;
				
			}

			//data
			data = strtol( pGrid->Cells[ 1][row +1].c_str() , &stop,  16);

			send_tcon( &data, data_size , rw_reg);
		}		
	}
}
//---------------------------------------------------------------------------

void __fastcall Ttcon_form::StringGrid1SelectCell(TObject *Sender,
      int ACol, int ARow, bool &CanSelect)
{
	pCurrent_Grid = (TStringGrid *)Sender;
       _current_row = ARow;
}
//---------------------------------------------------------------------------


void __fastcall Ttcon_form::timing_para(TObject *Sender)
{
	 TCheckBox *pCheck_box_Group[] = {CheckBox1,CheckBox2,CheckBox3,//CheckBox4,
                //CheckBox5,
                CheckBox6,CheckBox7,CheckBox8,CheckBox9,CheckBox10,
                CheckBox11,CheckBox12, CheckBox13,CheckBox14,
                //CheckBox15,           CheckBox24, //CheckBox,CheckBox,
        };

	TCheckBox *pControl = (TCheckBox *)Sender;

	byte data;
	int data_size = 1;
	PC_rw_register rw_reg = {write_reg_bit, 0, 0x487,1};

	int row = _current_row;
	int nbase_reg;
	char *stop;
	
	for(int  i =0; i<sizeof(pCheck_box_Group)/sizeof(TCheckBox *);i++)
       {
       	if(pControl == pCheck_box_Group[i])
		{
			rw_reg.startBit = sizeof(pCheck_box_Group) - i;
			send_tcon( &data, data_size , rw_reg);
		}	
	}                    
                                  
}
//---------------------------------------------------------------------------

#include "CA200SRVRLib_TLB.h"

void __fastcall Ttcon_form::get_data(TObject *Sender)
{
        typedef float(_cdecl *Connect)(float *R, float *G, float *B);
        typedef int(_cdecl *Connect_1)(float *f);

        typedef float(_cdecl *Connect)(float *R, float *G, float *B,
                                       float *x, float *y, float *lv,
                                       float *T, float *uv);
                                       
	HINSTANCE hinstDLL=NULL;
       hinstDLL=LoadLibrary("dll.dll");
	if (hinstDLL)
	{
		Connect Proc;
		Connect_1 Proc_1;
                
		float R[4][256];
		float G[4][256];
		float B[4][256];

		float x_group[4][256];
		float y_group[4][256];
		float lv_group[4][256];

		float T_group[4][256];
		float uv_group[4][256];		

		//float *f1[]={(float *)R, (float *)G};

              //////////////////////////////////////////////////////
		Proc_1 = (Connect_1)GetProcAddress (hinstDLL,"ca210_connect");
              Proc_1((float *)&R);

               //////////////////////////////////////////////////////
              
		Proc = (Connect)GetProcAddress (hinstDLL,"Test");
		float iValue = Proc((float *)&R, (float *)&G, (float *)&B,
			(float *)&x_group,  (float *)&y_group,  (float *)&lv_group,
			(float *)&T_group, (float *)&uv_group);
              
               //////////////////////////////////////////////////////
		FreeLibrary(hinstDLL);

	}
	else
	{
		ShowMessage("no dll");
	}

}
//---------------------------------------------------------------------------


void __fastcall Ttcon_form::draw_axis_frame(TObject *Sender)
{
        TCanvas *pCanvas = Image1->Canvas;

        TBrush *newBrush =    pCanvas->Brush;
        TBrush *poldBrush;
        // newBrush->Color = RGB(255,0,0);

	#define dig_length 6
	char dig[dig_length];
	pCanvas->Pen->Style = psDot;
	int nR = 240;
	pCanvas->Brush->Color = RGB(nR,nR,nR);

	int nbase=30;

	int xbase= 30;			
	int ybase= Image1->Height -20;
	int ngrid_y_base = ybase -5;

	int nY_max = Image1->Height -80;
	int nX_max = Image1->Width -nbase;
	int grid_Gap = 10;

	float y_gap = 25;       	
	y_gap =1250/50;

	///////////////////////////////////////////////////////////
	int y_axis_arrow = ngrid_y_base - nY_max -40;
	pCanvas->Pen->Style = psSolid;

	pCanvas->MoveTo(xbase, y_axis_arrow);  //y axis
	pCanvas->LineTo(xbase, ngrid_y_base);

	pCanvas->MoveTo(xbase, ngrid_y_base);       //x axis
	pCanvas->LineTo(xbase+nX_max, ngrid_y_base);

	pCanvas->LineTo(xbase+nX_max-10, ngrid_y_base-5);   //x axis arrow
	pCanvas->MoveTo(xbase+nX_max, ngrid_y_base);
	pCanvas->LineTo(xbase+nX_max-10, ngrid_y_base+5);

	pCanvas->MoveTo(xbase, y_axis_arrow);            //y axis arrow
	pCanvas->LineTo(xbase-5, y_axis_arrow+10);

	pCanvas->MoveTo(xbase, y_axis_arrow);
	pCanvas->LineTo(xbase+5, y_axis_arrow+10);

	///////////////////////////////////////////////////////////
	pCanvas->Pen->Style = psDot;        
        //grid
        for(int k=1;k<51;k++)
	{
                //x lines
		pCanvas->MoveTo(xbase, ngrid_y_base -k*grid_Gap);
		pCanvas->LineTo(xbase+ 50 * grid_Gap, ngrid_y_base-k*grid_Gap);

                //y lines
		pCanvas->MoveTo(xbase+k*grid_Gap, ngrid_y_base);
		pCanvas->LineTo(xbase+k*grid_Gap, ngrid_y_base- 50*grid_Gap);
	}

	/////////////////////////////////////////////////////////////
        //x axis  text
        int x_gap = 5;
	for(int i=0;i<52;i++)
	{
		if(i%2!=0)
		{			
			pCanvas->MoveTo(xbase+i*2*5, ngrid_y_base); 
			pCanvas->LineTo(xbase+i*2*5, ngrid_y_base-5);
		}
		else
		{
			if(i*5>100)
				pCanvas->TextOut(xbase+i*2*5-grid_Gap,  ybase,itoa(i* x_gap,dig,10));
			else
				pCanvas->TextOut(xbase+i*2*5-5,  ybase,itoa(i*x_gap,dig,10));

			pCanvas->Brush->Color = RGB(nR,0,0);
			pCanvas->MoveTo(xbase+i*2*5, ngrid_y_base);
			pCanvas->LineTo(xbase+i*2*5, ngrid_y_base-grid_Gap);
			pCanvas->Brush->Color = RGB(nR,nR,nR);
		}
	}

        //y axis   text
	for(int j=0;j<52;j++)
	{
		if(j%2!=0)
		{			
			pCanvas->MoveTo(xbase, ngrid_y_base-j*grid_Gap);
			pCanvas->LineTo(xbase+5, ngrid_y_base-j*grid_Gap);
		}
		else
		{		
			if(j*5<10)
			{				
				//pCanvas->TextOut(50-20+10,50+512-j*10-7,_itoa(j*5,dig,10));
			}
			else if(j*y_gap<1000)
			{
				
				pCanvas->TextOut(6,  ngrid_y_base-j*grid_Gap-7,itoa(j*y_gap,dig, 10));
			}
			else
			{
				pCanvas->TextOut(2,  ngrid_y_base-j*grid_Gap-7,itoa(j*y_gap,dig, 10));
			}      pCanvas->Brush->Color = RGB(nR,0,0);

			pCanvas->MoveTo(nbase, ngrid_y_base-j*grid_Gap);
			pCanvas->LineTo(nbase+grid_Gap,  ngrid_y_base-j*grid_Gap);
			pCanvas->Brush->Color = RGB(nR,nR,nR);
		}
	}
}
//---------------------------------------------------------------------------
/*
If (OptionCurve(2).value = True) Then
        Output_R(array_count) = ((array_count / 255) ^ Input_R) * 1024
        Output_G(array_count) = ((array_count / 255) ^ Input_G) * 1024
        Output_B(array_count) = ((array_count / 255) ^ Input_B) * 1024
*/
#include <math.h>
void __fastcall Ttcon_form::gamma_curve(TObject *Sender)
{
       TCanvas *pCanvas = Image1->Canvas;
        
        /////////////////////////////////////////////////////////////////////
        int nbase=50;

        int xbase= 30;			
        int ybase= Image1->Height -20;
        int ngrid_y_base = ybase -5;
	 
        int nY_max = Image1->Height -80;
        int nX_max = Image1->Width -50;
        int nGap_length = 10;

        float value;
        float a , b;
        b= 255;
        
        TEdit *pEdit_Group[] = {Edit4, Edit5, Edit6};
  	TColor color_group[] ={ RGB(255,0, 0),  RGB(0,255, 0),  RGB(0,0, 255)};	
        float Input_RGB;
        //float input_group[3];// = {0.5, 1.5,3};
        int gray;
	int gray_low , gray_high;
	gray_low = 0;
	gray_high = 255;

	float x_gap= 1.97;	// 2
	float y_gap= 0.49; // 0.5;
	
	//////////////////////////////////////////////////
	//clear prior curve               
       pCanvas-> Brush-> Color   =   clWhite;//±³¾°É«
	pCanvas-> Brush-> Style   =   bsSolid;//ÊµÌî³ä
	pCanvas-> FillRect(pCanvas-> ClipRect);//ÓÃ   Brush   Ìî³ä   Canvas   Õû¸öÇøÓò

        //axis
        draw_axis_frame(Sender);

	//////////////////////////////////////////////////	
	//R G B
	for(int i=0; i<3; i++)
	{
		pCanvas->Brush->Color = color_group[i];
 		pCanvas->MoveTo(xbase, ngrid_y_base);
		Input_RGB = atof(pEdit_Group[i]->Text.c_str());

	       for(gray= gray_low; gray < gray_high; gray++)
		{
	                a =   gray;
	                value = (a / b);
	                value = pow(value, Input_RGB) * 1024;

	                int x =  xbase + x_gap * gray;
	                int y =  ngrid_y_base - value * y_gap; //(value *nY_max)/1250;

			int nMax = 480;
			 if ((x > nMax ) && (y > nMax ))
                         {
                         	x = nMax;
			 	y = nMax;
                          }      
			 	
	                pCanvas->LineTo(x, y);
	        }
	}	
}

/////////////////////////////////////////////////////////////////////
float  get_x_axis_gap(int scope, int display_len)
{
	int gap;
	gap = display_len/scope;
}

/////////////////////////////////////////////////////////////////////
float  get_y_axis_gap(int scope, int display_len)
{
	int gap;
	gap = display_len/scope;
}
//---------------------------------------------------------------------------







